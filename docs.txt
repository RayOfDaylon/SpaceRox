Documentation for Stellar Mayhem game project

Author(s): Ray Gardener (support@daylongraphics.com)
Repository: https://github.com/RayOfDaylon/SpaceRox
May 31, 2023



Introduction
-------------------------------------------------------------------------------------
Stellar Mayhem is a remake of the classic Atari Asteroids 1979 arcade game which tries 
to match its look and feel, but coded using Unreal Engine (UE 5.1, specifically).

Its goals are a) to provide an educational reference for people interested in how 
this type of game works and how it can be made in UE, and b) to see if such a game 
using only UMG or Slate widgets would be performant enough (it is -- on my nVidia GTX 1050 TI
it gets between 60 and 120 fps). Another benefit (fwiw) is helping preserve the legacy of 
a classic arcade game.

While I've endeavoured to make the source code readable, the rest of this document 
may provide more clarification.

"SpaceRox" is the project's internal codename. It used to be the actual name, 
but it turns out there are other games already called that.

The change log was moved to the changelog.txt file. 


Project Structure
-------------------------------------------------------------------------------------
The repository should contain these items:

SpaceRox.uproject              UE project file

Config                         Various standard UE project .ini files

Content
    Audio                      Sounds
    Fonts                      The Hyperspace "vector" font
    Textures                   Asteroid, ship, etc. textures 
    Main                       The main (and only) level map
    PlayView                   The main (and only) UUserWidget for the viewport

Plugins
    DaylonGraphicsLibrary      Reusable code for widget-based 2D games
        DaylonUtils.*              Library routines and types
        SDaylonParticles.*         A widget used to efficiently draw explosions
        SDaylonLineParticles.*     A widget that draws explosions of lines
        SDaylonSprite.*            A widget used to draw animated textures
        docs.txt                   Plugin-specific documentation

Source
    SpaceRox
        Constants.h            Global constant values
        Arena.h                IArena interface class
        PlayViewBase.*         The overall game logic, implements IArena
        PlayObject.h           Base play object class (SDaylonSprite widget)
        Asteroid.*             Asteroid class
        Asteroids.*            Handles collection of asteroids
        EnemyShip.*            Enemy ship class (classic big and small enemies)
        EnemyShips.*           Handles all the enemy ships (including scavengers)
        Explosions.*           Manages all the explosions
        PlayerShip.*           The player's ship (technically a singleton)
        Powerup.*              Powerup class
        Scavenger.*            The scavenger enemy
        Torpedo.*              The bullets fired by all shooters
        AnimSpriteCel.h        Widget used to animate title graphic


Setting Up
-------------------------------------------------------------------------------------
You should already have UE installed (of course). As of this writing, the project 
uses UE 5.1. While higher versions should work, any changes made to assets may not 
be openable in earlier versions.

On Windows, right-click the .uproject file and choose "Generate Visual Studio project files".
The project should work with Visual Studio Community Edition 2019, and likely with others.

If you are getting launch errors, you may need to also right-click the .uproject file 
and choose "Switch Unreal Engine version" to associate it with the version of UE 
you have installed.

Once you have the project's .sln file, you can open it in Visual Studio and 
browse/modify/debug the code, build it, launch the development editor, etc.



How the Game is Played
-------------------------------------------------------------------------------------
If you've never played Atari Asteroids, I recommend finding an original arcade cabinet 
or an emulation, or at least watch one of the many YouTube videos available showing its 
gameplay (my own such video is at https://www.youtube.com/watch?v=mXKK6ThleVQ).

There are many variants, and Atari itself published a sequel called Asteroids Deluxe.
For our purposes, however, we'll concentrate on the original 1979 game.

Gameplay is straightforward: you pilot a ship on a 2D top-down playfield populated 
with several asteroids, your goal being to destroy them with torpedos. Once in a while 
enemy ships will also appear and you can destroy them as well (if not, they will 
eventually leave). With every 10,000 points you score, you earn an extra ship.

When hit, asteroids will break apart into two smaller rocks, until they are small 
enough that when hit, they simply explode and vanish. While asteroids can pass 
through each other, all other collisions are detrimental.

The playfield uses a wraparound facility to instantly teleport objects leaving one 
side to the opposite side. Torpedos are handled this way too, so you can shoot 
seemingly distant targets by aiming away from them.

Once all the asteroids are destroyed, a new wave of large asteroids will appear, 
with two more than before, up to 24 (assuming you survive that long).

The enemy ships come in two flavors: a large one that aims its torpedos randomly, 
and a small one that not only shoots precisely, but alternates targeting your 
ship and a randomly-chosen asteroid. The latter behavior was added to prevent 
the popular "hunt enemies when one rock is left" strategy -- eventually the 
playfield will be clear of asteroids. 
    When a small enemy ship appears, do not sit still or drift, or you will 
be shot.

Minibosses were added in version 1.8. These are shielded enemies that will 
fire randomly at first, then get more accurate. Bosses with a single shield 
layer will appear first, then dual-shielded bosses will become more common.
The shields are composed of multiple rotating segments that darken when hit, 
and your best strategy is to fly around to keep aiming at the darkest segments.
Their shields also drain when hit by asteroids and other enemy torpedos.

Powerups were added in version 1.4. One in four large asteroids will spawn 
containing a double-gun or shield powerup. The powerup will be transferred 
to one of the child rocks when the asteroid is split, until the asteroid 
is the smallest size. If hit, the powerup will float freely and the player 
ship can acquire it by colliding with it. Initially "floating" meant moving 
with the asteroid's inertia, but when lots of powerups were on the screen 
all moving around it became difficult to tell them apart from rocks, so 
I made them just hold their position. The powerup value readouts are in 
the upper right corner of the screen.

The shield powerup grants 20 seconds of shield time. Hold down the space bar 
to raise the shield. If your shield is hit, a few seconds of shield time 
will be deducted.

The double-gun (or power) powerup grants 100 double-shot rounds. The player ship 
will automatically switch to double guns if any such rounds have been acquired.
Double guns make a huge difference in destroying big and medium-sized asteroids, 
and overall improve your chances of hitting targets.

The invincibility (or star) powerup grants 30 seconds of invincibility 
taking effect immediately upon acquisition. A bright form-fitting shield 
will surround your ship. No time is removed for collisions. During the 
final five seconds, the shield will blink to alert you that it will soon collapse. 
A good strategy is to acquire this powerup as late as you can in the early waves, 
otherwise they will get used up when you don't really need them. In later waves, 
you want to prioritize them over everything else. You can use the normal shield 
at the same time, but it's redundant to do so.



Keyboard Issues
-----------------------------------------------------------------------------------
If you're having trouble getting key presses to register, your keyboard may 
have limited n-key rollover. Standard keyboards use the same circuitry for 
all the same keys in a row (to lower costs) but can make the keyboard unable 
to tell exactly which keys are being held down simultaneously. A gaming 
keyboard may be a better choice (they may indicate better rollover handling 
by calling it "anti-ghosting"). Some of them (like the MSI GK20) support 
more simultaneous keys in the QWE-ASD-ZXC area.

You can test how many simultaneous keys are recognized with a rollover tester.
There's one online at https://www.mechanical-keyboard.org/key-rollover-test/

If you want to change the default key assignments, open the project in the 
UE Editor, access Project Settings, Input and change the key assignments 
for the various input events, then repackage or play from the editor.

Typical keyboards lack the responsiveness of the original 
arcade cabinet pushbuttons, causing a suboptimal firing rate.
Although I can get small rapid-fire bursts, I find it 
only possible in brief moments. Your mileage may vary 
since there are many keyboard designs out there. One can 
also configure inputs from arcade-like controllers 
which may offer faster action.

The arcade pushbuttons are also better (at least, I think they were)
at allowing smaller rotation thrusts, letting you change your aim 
more slightly to improve asteroid demolition and hitting targets in general.
The Xbox gamepad joysticks seem to share the keyboard's coarser-grained 
rotating, which is frustrating but maybe a "gamma correction" or 
"smoothstep" force tuning can be used to make rotating from a 
standstill more accurate.



How the Game Works
-------------------------------------------------------------------------------------
The main data type (class) of interest is Daylon::PlayObject2D, defined in DaylonUtils.h.
Every object in the playfield is either a PlayObject2D or a subclass. This class 
subclasses a Slate widget and adds members for slot, render transform, 
an inertia (direction + speed) vector, the amount of life remaining in seconds, 
and a previous/current position. There are also methods to manage these values,
show/hide the widget, etc.

Generally, the term "widget" means "play object" when the widget is 
used as a play object.

Play object subclasses need an SWidget template argument in their 
inheritance declaration, and need to override GetActualSize(). 
Current SWidget types used are SImage and SDaylonSpriteWidget.
GetActualSize() is needed because GetSize() doesn't return e.g. 
the brush size despite Autosize(true) (at least not initally?).
When the brush is installed, UpdateWidgetSize() is called to 
force the widget's right/bottom parts of its slot Offset to 
be the brush size.

For greater abstraction, the game uses the Daylon::ImagePlayObject2D and 
Daylon::SpritePlayObject2D subclasses.

A play object's position is at the widget's center, which simplifies 
rotation and collision detection. This is achieved by using a canvas 
slot alignment of (0.5, 0.5). For rotations we also use a RenderTransform 
pivot of (0.5, 0.5).

All the play objects at runtime are TSharedPtr instances.

The player ship is its own UPlayViewBase member variable, while asteroids, 
enemies, torpedos etc. have their own classes wrapping TArray containers. 
Torpedos are preallocated in a fixed quantity since they are frequently getting 
created/destroyed. Explosions are a TArray of SDaylonParticleWidget* instead 
of being play objects because they don't need any logic besides appearing
on the screen. The player ship shield is its own widget as well. 
The player ship's thrust exhaust is implemented by just changing to 
a different overall brush for the ship.

Each play object class like FPlayerShip, FAsteroid, etc. have their 
own static Create() method to make new instances, and they just 
call SNew() and then Daylon::Install() to add the widget to the canvas. 
Daylon::Uninstall() is used to remove the widget from the canvas, 
and the TSharedPtr that was in the array is then erased or reset, 
and as the last reference to the widget, the widget is truly gone. 
Internally, SNew and TSharedPtr's resource allocator/releaser default to 
operator new/delete (although, like stdlib, they do allow custom allocators).

The UPlayViewBase class is a UUserWidget holding the game logic. A blueprint 
subclass "PlayView" is used to hold design-time objects like menus, info displays, etc.
the "BindWidget" meta tag is used on several class UWidget members so that 
the C++ code can manipulate these design-time objects. There are also audio 
and texture (brush) members, and some properties for testing.

UPlayViewBase mixes in the IArena interface class, so that tightly coupled 
classes like FExplosions, FEnemyShips, etc. don't need to know about UPlayViewBase.

There's barely any Blueprint script (I started off using it, but it soon 
became unwieldy). Instead, BP script is used to simply forward input events to 
the C++ code. Speaking of which, the input actions are mapped only to keyboard 
keys for now. Being inside binary files, BP script is also impossible to 
simultaneously edit in team environments.

The UPlayerController, UGameInstance, UGameMode, APawn, etc. classes aren't used 
(or are hardly used at all), and neither are Actors. While a game is normally 
structured along those lines, for better or worse I just found it easier to
skip all that, and it's a testament to UE that one can implement things in 
many different ways.

Everything pretty much happens inside the main UUserWidget.
UPlayViewBase::NativeOnInitialized sets up the game, and from there, 
UPlayViewBase::NativeTick drives the gameplay.

What happens during NativeTick depends on the current game state, 
which is enumerated in the EGameState type. From its comment, the 
state transition graph is:

	Startup --> Intro

	Intro ---> Menu

	Menu -- (start chosen)       --> Active
	     -- (help chosen)        --> Help           --> Menu
	     -- (credits chosen)     --> Credits        --> Menu
	     -- (high scores chosen) --> High scores    --> Menu

	Active -- (player dies)      --> Over
	       -- (Esc pressed)      --> Menu
								     
	Over -- (high score?)        --> HighScoreEntry --> Menu
	     -- (no high score)      --> Menu


The UPlayViewBase::TransitionToState method lets one leave the current 
state and enter a different state. Each state takes care of hiding 
and showing the various widgets it needs.

For speed, widgets are hidden using the Collapsed option, so that 
their geometry isn't considered at all. When visible, the 
HitTestInvisible option skips processing of any inputs, since 
the game is directly listening for button presses (keystrokes).

To make torpedos appear bright, all other widgets are tinted 
to half brightness.

Constant values are normally declared with friendly names 
at the top of the PlayViewBase.cpp file.

UPlayViewBase::NativeTick dispatches to other per-frame methods 
depending on the current game state. It also calls UpdateTasks, 
which processes any active tasks in the ScheduledTasks and 
DurationTasks arrays. Scheduled tasks are handy to fire off 
events that need to occur some time in the future, e.g. the 
secondary player ship explosion. Duration tasks are not 
currently used.

Various other UPlayViewBase members handle timing related 
to starting waves, spawning the player, etc.

For the Active game state, NativeTick will process the 
various inputs (thrust, rotate, fire), move all the 
visible objects, and process any collisions. When the 
player has no more ships, it transitions to the Over 
state which flashes the "GAME OVER" message, which itself 
then transitions to HighScoreEntry or back to MainMenu.

To be accurate, collision detection uses the OldPosition 
and UnwrappedNewPosition members of the FPlayObject 
to test intersections between line segments and circles/triangles. 
Otherwise, fast-moving objects could be on either side 
of another object from one frame to the next, resulting 
in a false negative.

To avoid unwanted self-intersections when firing torpedos, 
the FTorpedo class includes a FiredByPlayer member 
which lets shooters avoid friendly fire.

Since 1.6, multiple enemy ships can appear together.

Enemy ship movement is fairly simple: a random Y-position 
along a screen edge is chosen, a left/right direction 
is randomly chosen, and during flight at certain 
intervals, a random heading is chosen which can be 
straight, or upwards/downwards at 45 degrees.

Sounds have to be preloaded to avoid playing noticeably 
later than they should. Preloading is hacked by simply 
playing all the sound assets at startup at a very low volume.

Looped sounds are necessary for enemy ships and the 
thrust of the player ship. This is also hacked by just 
keeping track of time during NativeTick and when a 
sound has been fully played, it gets replayed. The 
FLoopedSound class simplifies this.

High scores are kept in a highscores.txt file.
In development mode, this will be in the project's 
Saved folder. In packaged Shipping builds, the 
file should be in /Users/.../AppData/Local/SpaceRox/Saved.


Future Work
-------------------------------------------------------------------------------------
A sector map has been added but is not currently used.
It's part of a planned upgrade to sector-based gameplay
instead of waves. We'll eventually get rid of the player score 
and the high score table as well.

It would be good to add component members to FPlayObject2D to avoid 
doing the subclasses' features entirely by inheritance, to have 
class dtors automatically remove widgets from the canvas.

We could have all the torpedos be drawn by a single 
Slate widget similar to how SDaylonParticles works, 
removing 20-30 widgets from the scenegraph.

There's still some duplicate code so we want patterns or function consolidation.

The player-rock collision detection seems to be a bit too generous 
in some cases.
